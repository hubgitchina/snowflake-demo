# snowflake-demo

基于雪花算法的原理

snowflake的结构如下(每部分用-分开):

0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000

第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）

一共加起来刚好64位，为一个Long型。(转换成字符串后长度最多19)

snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。经测试snowflake每秒能够产生26万个ID。

1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0
41位，用来记录时间戳（毫秒）。

41位可以表示241−1个数字，
如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 241−1，减1是因为可表示的数值范围是从0开始算的，而不是1。
也就是说41位可以表示241−1个毫秒的值，转化成单位年则是(241−1)/(1000∗60∗60∗24∗365)=69年
10位，用来记录工作机器id。

可以部署在210=1024个节点，包括5位datacenterId和5位workerId
5位（bit）可以表示的最大正整数是25−1=31，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId
12位，序列号，用来记录同毫秒内产生的不同id。

12位（bit）可以表示的最大正整数是212−1=4095，即可以用0、1、2、3、....4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号

由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。

SnowFlake可以保证：

所有生成的id按时间趋势递增
整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）



在互联网软件产品应用中，订单号的生成看似简单，实则非常重要的一环。尤其在分布式系统架构中，更是关系到系统性能，用户体验，数据查找和分析，商业机密等重要信息。

本例实现为：
调整二进制的运算方式和位数表示的意义，有效缩短生成ID的位数，增加可读性。
1，	先计算当前时间与系统预设时间的时间戳差值
2，	将用于高并发下的毫秒序列变量，进行时间戳差值二进制位数的左位移
3，	将生成的ID进行反转，后面可跟上数据库分片分表标识
最终得到分布式系统内，高效不唯一，同时可读性高，又不会泄露业务量等商业机密信息。

效解决多用户同时访问系统时，高并发下，订单号的快速生成，同时保证生成ID全局唯一性，位数也不会过长，提高可读性，也没有雪花算法69年使用时限的限制。在大数据检索和分析上，在分布式架构中，更能快速定位相关片区的库和表，提高效率。处理过的ID，生产出了不会具备连续可读性，从而提高了安全性，不会透露出业务量等重要信息。更可衍生到其它业务数据的主键ID生产中应用。
